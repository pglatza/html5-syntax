datatypes w = "http://whattf.org/datatype-draft"

# #####################################################################
##  RELAX NG Schema for HTML 5: Global Structure & Meta Data          #
# #####################################################################

## Root Element: <html>

	html.elem =
		element html { html.inner & html.attrs }
	html.attrs =
		# This hack lets us restrict xml:base to <html> when nonRoundtrippable is empty
		# credits to http://relaxng.org/pipermail/relaxng-user/2004-February/000384.html
		grammar {
			html.elem = parent html.elem
			include "common.rnc" {
				start = common.attrs
				common.attrs.base = common.attrs.xmlbase
			}
		}
	html.inner =
		(	head.elem
		,	body.elem
		)

## Meta Data Container: <head>

	head.elem =
		element head { head.inner & head.attrs }
	head.attrs =
		(	common.attrs
#		&	head.attrs.profile?
		)
#		head.attrs.profile =
#			attribute profile {
#				common.data.uris #REVISIT should these be absolute (zero or more)
#			}
	head.inner =
		(	meta.elem.encoding?
		,	base.elem?
		,	(	title.elem
			&	common.inner.metadata
			)
		)
		
## Content Container: <body>

	body.elem =
		element body { body.inner & body.attrs }
	body.attrs =
		( common.attrs )
	body.inner =
		( common.inner.block )

## Document Title: <title>

	title.elem =
		element title { title.inner & title.attrs }
	title.attrs =
		( empty )
	title.inner =
		( text )

## Base URI: <base>

	base.elem =
		element base { base.inner & base.attrs }
	base.attrs =
		(	common.attrs
		&	base.attrs.href?
		&	base.attrs.target?
		)
	base.attrs.href =
		attribute href {
			common.data.uri
		}
	base.attrs.target =
		attribute target {
			common.data.browsingcontext
		}
	base.inner =
		( empty )

## Global Relationships: <link>

	link.elem =
		element link { link.inner & link.attrs }
	link.attrs =
		(	common.attrs
		&	link.attrs.href
		&	link.attrs.rel
		&	link.attrs.hreflang?
		&	link.attrs.media?
		&	link.attrs.type?
		#	link.attrs.title included in common.attrs
		)
		link.attrs.href =
			attribute href {
				common.data.uri
			}
		link.attrs.rel =
			attribute rel {
				common.data.tokens
			}
		link.attrs.hreflang =
			attribute hreflang {
				common.data.langcode
			}
		link.attrs.media =
			attribute media {
				common.data.mediaquery
			}
		link.attrs.type =
			attribute type {
				common.data.mimetype
			}
	link.inner =
		( empty )
		
	common.elem.metadata |= link.elem

## Global Style: <style>

	style.elem =
		element style { style.inner & style.attrs }
	style.attrs =
		(	common.attrs
		&	style.attrs.type?
		&	style.attrs.media?
		#	style.attrs.title included in common.attrs
		)
		style.attrs.type =
			attribute type {
				common.data.mimetype
			}
		style.attrs.media =
			attribute media {
				common.data.mediaquery
			}
	style.inner =
		( common.inner.anything )
		
	common.elem.metadata |= style.elem

## Scoped Style: <style scoped>

	style.elem.scoped =
		element style { style.inner & style.scoped.attrs }
	style.scoped.attrs =
		(	common.attrs
		&	style.attrs.type?
		&	style.attrs.media?
		&	style.attrs.scoped
		#	style.attrs.title included in common.attrs
		)
		style.attrs.scoped =
			attribute scoped {
				w:string "scoped" | w:string ""
			}

## Name-Value Meta Data: <meta name>

	meta.elem.name =
		element meta { meta.name.inner & meta.name.attrs }
	meta.name.attrs =
		(	common.attrs
		&	meta.name.attrs.name
		&	meta.name.attrs.content
		)
		meta.name.attrs.name =
			attribute name {
				string
			}
		meta.name.attrs.content =
			attribute content {
				string
			}
	meta.name.inner =
		( empty )
		
	common.elem.metadata |= meta.elem.name

## Pragma Directives: <meta http-equiv>

	meta.elem.http-equiv =
		element meta { meta.http-equiv.inner & meta.http-equiv.attrs }
	meta.http-equiv.attrs =
		(	common.attrs
		&	(	(	meta.http-equiv.attrs.http-equiv.refresh
				&	meta.http-equiv.attrs.content.refresh
				)
			|	(	meta.http-equiv.attrs.http-equiv.default-style
				&	meta.http-equiv.attrs.content.default-style
				)
			)
		)
		meta.http-equiv.attrs.http-equiv.refresh =
			attribute http-equiv {
				w:string "refresh"
			}
		meta.http-equiv.attrs.http-equiv.default-style =
			attribute http-equiv {
				w:string "default-style"
			}
		meta.http-equiv.attrs.content.refresh =
			attribute content { 
				string # XXX datatype
			}
		meta.http-equiv.attrs.content.default-style =
			attribute content {
				string
			}
	meta.http-equiv.inner =
		( empty )
		
	common.elem.metadata |= meta.elem.http-equiv # not quite right per spec
	                                             # if the definition is 
	                                             # reused in another language


## Inline Character Encoding Statement for HTML: <meta charset>

	meta.elem.encoding =
		element meta { meta.encoding.inner & meta.encoding.attrs }
		& HTMLonly
	meta.encoding.attrs =
		(	common.attrs
		&	meta.attrs.charset
		)
		meta.attrs.charset =
			attribute charset {
				string #FIXME need a datatype with IANA data here
			}
	meta.encoding.inner =
		( empty )		

