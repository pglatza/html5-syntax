datatypes w = "http://whattf.org/datatype-draft"

# #####################################################################
##  RELAX NG Schema for HTML 5: Web Application Features              #
# #####################################################################

## Additions to Common Attributes

	common.attrs.interact &=
		(	common.attrs.contextmenu?
		&	common.attrs.contenteditable?
		&	common.attrs.draggable?
		&	common.attrs.irrelevant?
		)
		
	common.attrs.other &= common.attrs.interact

## Context Menu: contextmenu

	common.attrs.contextmenu =
		attribute contextmenu {
			common.data.idref
		}

## Editable Content: contenteditable

	common.attrs.contenteditable =
		attribute contenteditable {
			w:string "true" | w:string "false"
		}

## Draggable Element: draggable

	common.attrs.draggable =
		attribute draggable {
			w:string "true" | w:string "false"
		}

## Irrelevant Attribute: irrelevant

	common.attrs.irrelevant =
		attribute irrelevant {
			w:string "irrelevant" | w:string ""
		}

## Application Cache: manifest

	html.attrs.manifest =
		attribute manifest {
			common.data.uri
		}
		
	html.attrs &= html.attrs.manifest?

## Progess Indicator: <progress>

	progress.elem =
		element progress { progress.inner & progress.attrs }
	progress.attrs =
		(	common.attrs
		&	progress.attrs.value?
		&	progress.attrs.max?
		)
		progress.attrs.value =
			attribute value {
				common.data.float.non-negative #REVISIT
			}
		progress.attrs.max =
			attribute max {
				common.data.float.positive #REVISIT
			}
	progress.inner =
		( common.inner.phrase ) #Cannot enforce textContent format here

	common.elem.phrase |= progress.elem

## Datagrid: <datagrid>

	datagrid.elem =
		element datagrid { datagrid.inner & datagrid.attrs }
	datagrid.attrs =
		(	common.attrs
		&	datagrid.attrs.multiple?
		&	datagrid.attrs.disabled?
		)
		datagrid.attrs.multiple =
			attribute multiple {
				w:string "multiple" | w:string ""
			}
		datagrid.attrs.disabled =
			attribute disabled {
				w:string "disabled" | w:string ""
			}
	datagrid.inner =
		(	common.inner.prose # table case left to schematron 
		|	select.elem
		|	datalist.elem.prose
		)
	
	common.elem.prose |= datagrid.elem

## Command: <command>

	command.elem =
		element command { command.inner & command.attrs }
	command.attrs =
		(	common.attrs
		&	(	command.attrs.type.command
			|	(	command.attrs.type.radio
				&	command.attrs.radiogroup #REVISIT taking liberties here
				&	command.attrs.checked?
				)
			|	(	command.attrs.type.checkbox
				&	command.attrs.checked?
				)
			)?
		&	command.attrs.label?
		&	command.attrs.icon?
		&	command.attrs.hidden?
		&	command.attrs.disabled?
		&	command.attrs.default?
		)
		command.attrs.type.command =
			attribute type {
				w:string "command"
			}
		command.attrs.type.radio =
			attribute type {
				w:string "radio"
			}
		command.attrs.type.checkbox =
			attribute type {
				w:string "checkbox"
			}
		command.attrs.label =
			attribute label {
				string
			}
		command.attrs.icon =
			attribute icon {
				common.data.uri
			}
		command.attrs.hidden =
			attribute hidden {
				w:string "hidden" | w:string ""
			}
		command.attrs.disabled =
			attribute disabled {
				w:string "disabled" | w:string ""
			}
		command.attrs.checked =
			attribute checked {
				w:string "checked" | w:string ""
			}
		command.attrs.radiogroup =
			attribute radiogroup {
				string #REVISIT need special format here?
			}
		command.attrs.default =
			attribute default {
				w:string "default" | w:string ""
			}
	command.inner =
		( empty )
	
	common.elem.metadata |=
		( command.elem & nonHTMLizable )
	common.elem.phrase |= command.elem

## Menu: <menu>

	menu.elem =
		element menu { menu.inner & menu.attrs }
	menu.attrs =
		(	common.attrs
		&	menu.attrs.type?
		&	menu.attrs.label?
		&	menu.attrs.autosubmit?
		)
		menu.attrs.type =
			attribute type {
				w:string "toolbar" | w:string "context"
			}
		menu.attrs.label =
			attribute label {
				string
			}
		menu.attrs.autosubmit =
			attribute autosubmit {
				w:string "autosubmit" | w:string ""
			}
	menu.inner =
		(	mli.elem.phrase*
		|	common.inner.phrase
		)
	
	common.elem.prose |= menu.elem
	# REVISIT allow nested menus

## Menu Item: <li>

	mli.elem =
		element li { mli.inner & mli.attrs }
	mli.elem.phrase =
		element li { mli.inner.phrase & mli.attrs }
	mli.attrs =
		( common.attrs )
	mli.inner =
		( common.inner.prose )
	mli.inner.phrase =
		( common.inner.phrase )
	
## Canvas for Dynamic Graphics: <canvas>

	canvas.elem.prose =
		element canvas { canvas.inner.prose & canvas.attrs }
	canvas.elem.embedded =
		element canvas { canvas.inner.embedded & canvas.attrs }
	canvas.attrs =
		(	common.attrs
		&	canvas.attrs.height?
		&	canvas.attrs.width?
		&	common.attrs.aria?
		)
		canvas.attrs.height =
			attribute height {
				common.data.integer.non-negative
			}
		canvas.attrs.width =
			attribute width {
				common.data.integer.non-negative
			}
	canvas.inner.prose =
		( common.inner.prose )
	canvas.inner.embedded =
		( common.inner.phrase )
	
	common.elem.prose |= canvas.elem.prose
	common.elem.embedded |= canvas.elem.embedded

## Server-sent events: <event-source>

	event-source.elem =
		element event-source { event-source.inner & event-source.attrs }
	event-source.attrs =
		(	common.attrs
		&	event-source.attrs.src?
		)
		event-source.attrs.src =
			attribute src {
				common.data.uri
			}
	event-source.inner =
		( empty )

	common.elem.metadata |= ( event-source.elem & nonHTMLizable )
	common.elem.phrase |= event-source.elem
	
## Additional On-Demand Information: <details>

	details.elem =
		element details { details.inner & details.attrs }
	details.attrs =
		(	common.attrs
		&	details.attrs.open?
		&	common.attrs.aria.implicit.region?
		)
		details.attrs.open =
			attribute open {
				w:string "open" | w:string ""
			}
	details.inner =
		(	legend.elem
		,	common.inner.prose 
		)
	
	common.elem.prose |= details.elem
