datatypes w = "http://whattf.org/datatype-draft"

# #####################################################################
##  RELAX NG Schema for HTML 5: Common Definitions                    #
# #####################################################################


# #####################################################################
##  Language Parameters - redefine in inclusion block as necessary    #
# #####################################################################

## Root Definition

	start = html.elem

## HTML vs. XHTML restrictions

	XMLonly = empty
	HTMLonly = notAllowed

## HTML 4 Compatibility - set to notAllowed to disallow markup introduced in HTML 5
#                         (This only affects mixed-version modules; wholly HTML5
#                          modules should simply be left out of the inclusion list.)

	v5only = empty

## HTML Compatibility Switches - set to notAllowed to disallow

	## XML features that can't be roundtripped HTML <-> XHTML
	#  (xml:base on elements other than <html>)
	nonRoundtrippable = empty

	## XML features that can't be serialized as HTML
	#  (structured inline elements in <p>)
	nonHTMLizable = empty

# #####################################################################
##  Wildcards                                                         #
# #####################################################################

## Any attribute from any namespace

	common.attr.anything =
#		attribute * { text }*
		attribute foo { text }*

## Any element from any namespace

	common.elem.anything =
		element * { common.inner.anything & common.attr.anything }

## Any content from any namespace

	common.inner.anything =
		(	text
		&	common.elem.anything*
		)

# #####################################################################
##  Deletion Hooks                                                    #
# #####################################################################

	common.del.strict-inline =
		( notAllowed )
	common.del.strict-inline.static =
		( notAllowed )
	common.del.struct-inline =
		( notAllowed )
	common.del.struct-inline.static =
		( notAllowed )
	common.del.block =
		( notAllowed )
	common.del.block.static =
		( notAllowed )

# #####################################################################
##  Common Element Classes                                            #
# #####################################################################

## Strictly Inline Elements

	common.elem.strict-inline =
		( notAllowed )

	common.elem.strict-inline.static =
		( notAllowed )

## Structured Inline Elements

	common.elem.struct-inline =
		( notAllowed )

	common.elem.struct-inline.static =
		( notAllowed )

## Block Elements

	common.elem.block =
		( notAllowed )

	common.elem.block.static =
		( notAllowed )

## Embedded Content

	common.elem.embedded =
		( notAllowed )

	common.elem.embedded.static =
		( notAllowed )

# #####################################################################
##  Common Content Models                                             #
# #####################################################################

## Strictly Inline Content

	common.inner.strict-inline =
		( text & common.elem.strict-inline* )

	common.inner.strict-inline.static =
		( text & common.elem.strict-inline.static* )

## Structured Inline Content

	common.inner.struct-inline =
		( text & common.elem.struct-inline* )

	common.inner.struct-inline.static =
		( text & common.elem.struct-inline.static* )

## Block Content

	common.inner.block =
		(common.elem.block* )

	common.inner.block.static =
		( common.elem.block.static* )

## Inline OR Block Content

	common.inner.bimorphic =
		(	(	text
			&	(	common.elem.struct-inline
				|	common.del.block
				)*
			)
		|	(	common.elem.block
			|	common.del.struct-inline
			)*
		)

	common.inner.bimorphic.static =
		(	(	text
			&	(	common.elem.struct-inline.static
				|	common.del.block.static
				)*
			)
		|	(	common.elem.block.static
			|	common.del.struct-inline.static
			)*
		)

## Strict Inline OR Block Content

	#REVISIT remove if wf1 doesn't really need these

	common.inner.strict-bimorphic =
		(	(	text
			&	(	common.elem.strict-inline
				|	common.del.block
				)*
			)
		|	(	common.elem.block
			|	common.del.strict-inline
			)*
		)

	common.inner.strict-bimorphic.static =
		(	(	text
			&	(	common.elem.strict-inline.static
				|	common.del.block.static
				)*
			)
		|	(	common.elem.block.static
			|	common.del.strict-inline.static
			)*
		)

# #####################################################################
##  Common Attributes                                                 #
# #####################################################################

# When updating, check <bdo> definition too

common.attrs =
	(	common.attrs.basic
	&	common.attrs.i18n
	&	common.attrs.present
	&	common.attrs.other
	)

common.attrs.basic =
	(	(	common.attrs.id
		|	common.attrs.xml-id
		)? # REVISIT assuming only either one is allowed
	&	common.attrs.class?
	&	common.attrs.title?
	&	common.attrs.base?
	)
	common.attrs.id =
		attribute id {
			common.data.id
		}
	common.attrs.xml-id =
		attribute xml:id {
			xsd:ID
		} & XMLonly
	common.attrs.class =
		attribute class {
			common.data.tokens
		}
	common.attrs.title =
		attribute title {
			text
		}
	common.attrs.base =
		common.attrs.xmlbase
		& nonRoundtrippable
	common.attrs.xmlbase =
		attribute xml:base {
			xsd:anyURI
		} & XMLonly

common.attrs.i18n =
	(	common.attrs.dir?
	&	common.attrs.language?
	)
	common.attrs.dir =
		attribute dir {
			string "ltr" | string "rtl"
		}
	common.attrs.language =
		(	common.attrs.lang
		|	common.attrs.xmllang
		)
	common.attrs.lang =
		attribute lang {
			common.data.langcode
		} & HTMLonly
	common.attrs.xmllang =
		attribute xml:lang {
			common.data.langcode
		} & XMLonly

common.attrs.present =
	(	common.attrs.style?
	&	common.attrs.tabindex?
	)
	common.attrs.style =
		attribute style {
			string
		}
	common.attrs.tabindex =
		attribute tabindex {
			common.data.integer
		}

common.attrs.other =
	empty

# #####################################################################
##  Common Datatypes                                                  #
# #####################################################################

## Names and Tokens

	common.data.tokens =
		list { token* }
		
	common.data.tokens.comma-separated =
		xsd:string {
			pattern = "[^,]+(,[^,]+)*"
		}

	common.data.character = 
		string #FIXME

## IDs and IDREFs

	common.data.id =
		xsd:string {
			pattern = ".+"
		}

	common.data.idref =
		string #REVISIT

	common.data.idrefs =
		string #REVISIT

	common.data.hashed-idref =
		xsd:string {
			pattern = "#.+"
		}

## Numerical

	common.data.integer =
		xsd:string {
			pattern = "-?[0-9]+"
		}

	common.data.integer.positive =
		xsd:string {
			pattern = "0*[1-9][0-9]*"
		}

	common.data.integer.non-negative =
		xsd:string {
			pattern = "[0-9]+"
		}
		
	common.data.percent =
		xsd:string {
			pattern = "(100)|([1-9]?[0-9](\.[0-9]+)?)%"
		}
		
	common.data.float =
		xsd:string {
			pattern = "-?((\.[0-9]+)|([0-9]+(\.[0-9]*)?))"
		}

	common.data.float.positive =
		xsd:string {
			pattern = "0*((\.0*[1-9][0-9]*)|([1-9][0-9]*(\.[0-9]*)?))"
		}
		
	common.data.float.non-negative =
		xsd:string {
			pattern = "((\.[0-9]+)|([0-9]+(\.[0-9]*)?))"
		}
		
## Temporal

	common.data.datetime =
		w:datetime-tz

	common.data.date-or-time =
		w:date-or-time

	common.data.timeoffset =
		string #FIXME

## IRIs

	common.data.uri =
		string "" | w:iri-ref

	common.data.uris =
		list { w:iri-ref* }

	common.data.uri.absolute =
		w:iri

## MIME types

	common.data.mimetype =
		string #FIXME import regex later

	#REVISIT is this one needed?
	common.data.mimetype.no-params =
		string #FIXME import regex later

## Media Queries

	common.data.mediaquery =
		string #FIXME import regex later

## Language Codes

	common.data.langcode =
		xsd:language #FIXME import refined datatype later, XSD is way too coarse
