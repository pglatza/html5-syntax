# #####################################################################
##  RELAX NG Schema for HTML 5: Web Forms 1.0 markup                  #
# #####################################################################

## Shared attributes for form controls

	common-form.attrs =
		(	common-form.attrs.name?
		&	common-form.attrs.disabled?
		)
		
	common-form.attrs.name = 
		attribute name {
			string #REVISIT should this be restricted somehow? No & and = perhaps?
		}

	common-form.attrs.disabled = 
		attribute disabled {
			string "disabled"
		}

	common-form.attrs.accesskey = 
		attribute accesskey {
			common.data.character
		}

	common-form.attrs.readonly = 
		attribute readonly {
			string "readonly"
		}

	common-form.attrs.maxlength = 
		attribute maxlength {
			common.data.integer.positive #REVISIT should this be non-negative?
		}
	
	# REVISIT tabindex goes in common.attrs

## Shared attributes for <input>
	
	input.attrs.checked = 
		attribute checked {
			string "checked"
		}

## Text Field: <input type='text'>

	input.text.elem = 
		element input { input.text.attrs }
	input.text.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.text.attrs.type?
		&	common-form.attrs.accesskey?
		&	common-form.attrs.maxlength? 
		&	common-form.attrs.readonly? 
		&	input.text.attrs.value? 
		)		
		input.text.attrs.type = 
			attribute type {
				string "text"
			}
		input.text.attrs.value =
			attribute value {
				string #REVISIT "nominally" free of line breaks?
			}
		
	input.elem = input.text.elem

## Password Field: <input type='password'>

	input.password.elem = 
		element input { input.password.attrs }
	input.password.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.password.attrs.type
		&	common-form.attrs.accesskey?
		&	common-form.attrs.maxlength? 
		&	common-form.attrs.readonly? 
		&	input.password.attrs.value? 
		)
		input.password.attrs.type = 
			attribute type {
				string "password"
			}
		input.password.attrs.value =
			attribute value {
				string #REVISIT "nominally" free of line breaks?			
			}
		
	input.elem |= input.password.elem
		
## Checkbox: <input type='checkbox'>

	input.checkbox.elem = 
		element input { input.checkbox.attrs }
	input.checkbox.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.checkbox.attrs.type
		&	common-form.attrs.accesskey?
		&	input.attrs.checked? 
		&	input.checkbox.attrs.value? 
		)
		input.checkbox.attrs.type = 
			attribute type {
				string "checkbox"
			}
		input.checkbox.attrs.value =
			attribute value {
				string #REVISIT require non-empty value?
			}
		
	input.elem |= input.checkbox.elem
	
## Radiobutton: <input type='radio'>

	input.radio.elem = 
		element input { input.radio.attrs }
	input.radio.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.radio.attrs.type
		&	common-form.attrs.accesskey?
		&	input.attrs.checked? 
		&	input.radio.attrs.value? 
		)
		input.radio.attrs.type = 
			attribute type {
				string "radio"
			}
		input.radio.attrs.value =
			attribute value {
				string #REVISIT require non-empty value?
			}
		
	input.elem |= input.radio.elem
	
## Scripting Hook Button: <input type='button'>

	input.button.elem = 
		element input { input.button.attrs }
	input.button.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.button.attrs.type
		&	common-form.attrs.accesskey?
		&	input.button.attrs.value? 
		)
		input.button.attrs.type = 
			attribute type {
				string "button"
			}
		input.button.attrs.value =
			attribute value {
				string #REVISIT require non-empty value?
			}
		
	input.elem |= input.button.elem
	#REVISIT should this be enabled by a scripting module only?
	
## Submit Button: <input type='submit'>

	input.submit.elem = 
		element input { input.submit.attrs }
	input.submit.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.submit.attrs.type
		&	common-form.attrs.accesskey?
		&	input.submit.attrs.value? 
		)
		input.submit.attrs.type = 
			attribute type {
				string "submit"
			}
		input.submit.attrs.value =
			attribute value {
				string #REVISIT require non-empty value?
			}
		
	input.elem |= input.submit.elem
		
## Reset Button: <input type='reset'>

	input.reset.elem = 
		element input { input.reset.attrs }
	input.reset.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.reset.attrs.type
		&	common-form.attrs.accesskey?
		&	input.reset.attrs.value? 
		)
		input.reset.attrs.type = 
			attribute type {
				string "reset"
			}
		input.reset.attrs.value =
			attribute value {
				string #REVISIT require non-empty value?
			}
		
	input.elem |= input.reset.elem
	# REVISIT does reset make sense outside a form?
		
## File Upload: <input type='file'>

	input.file.elem = 
		element input { input.file.attrs }
	input.file.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.file.attrs.type
		&	input.file.attrs.accept?
		&	common-form.attrs.accesskey?
		)
		input.file.attrs.type = 
			attribute type {
				string "file"
			}
		input.file.attrs.accept = 
			attribute accept {
				form.data.mimetypelist
			}

	input.elem |= input.file.elem
	
## Hidden String: <input type='hidden'>

	input.hidden.elem = 
		element input { input.hidden.attrs }
	input.hidden.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.hidden.attrs.type
		&	input.hidden.attrs.value? 
		)
		input.hidden.attrs.type = 
			attribute type {
				string "hidden"
			}
		input.hidden.attrs.value =
			attribute value {
				string
			}
		
	input.elem |= input.hidden.elem
		
## Image Submit Button: <input type='image'>

	input.image.elem = 
		element input { input.image.attrs }
	input.image.attrs = 
		(	common.attrs
		&	common-form.attrs
		&	input.image.attrs.type
		&	common-form.attrs.accesskey?
		&	input.image.attrs.alt? 
		&	input.image.attrs.src? 
		)	
		input.image.attrs.type = 
			attribute type {
				string "image"
			}
		input.image.attrs.alt = 
			attribute alt {
				string
			}
		input.image.attrs.src = 
			attribute src {
				common.data.uri
			}
	
	input.elem |= input.image.elem
	
	common.inner.struct-inline &= input.elem*
	common.inner.strict-inline &= input.elem*
	# REVISIT should hidden also go to static?

## Text Area: <textarea>

	textarea.elem =
		element textarea { textarea.inner & textarea.attrs }
	textarea.attrs =
		(	common.attrs
		&	common-form.attrs
		&	common-form.attrs.accesskey?
		&	common-form.attrs.readonly?
		&	textarea.attrs.rows-and-cols-wf1
		#FIXME onfocus, onblur, onselect,onchange
		)
		# This is ugly. 
		textarea.attrs.rows-and-cols-wf1 = 
			textarea.attrs.rows-and-cols-wf1.inner	
		textarea.attrs.rows-and-cols-wf1.inner =
			(	textarea.attrs.cols
			&	textarea.attrs.rows
			)
		textarea.attrs.cols = 
			attribute cols {
				common.data.integer.positive
			}
		textarea.attrs.rows = 
			attribute rows {
				common.data.integer.positive
			}
	textarea.inner =
		( text )

	common.inner.struct-inline &= textarea.elem*
	common.inner.strict-inline &= textarea.elem*

# Due to limitations with interleave, handling single/multiple selection
# enforcement in RELAX NG seems to be possible but really awkward.
# Tried it. Leaving it to Schematron.

## Select menu option (selected): <option selected>

	option.elem =
		element option { option.inner & option.attrs }
	option.attrs =
		(	common.attrs
		&	common-form.attrs.disabled?
		&	option.attrs.selected?
		&	option.attrs.label?
		&	option.attrs.value?
		)
		option.attrs.selected =
			attribute selected {
				string "selected"
			}
		option.attrs.label =
			attribute label {
				string
			}		
		option.attrs.value =
			attribute value {
				string
			}		
	option.inner =
		( text )

## Option Group: <optgroup>

	optgroup.elem =
		element optgroup { optgroup.inner & optgroup.attrs }
	optgroup.attrs = 
		( optgroup.attrs.label )
		optgroup.attrs.label =
			attribute label {
				string
			}
	optgroup.inner =
		( option.elem* )

## Selection Menu: <select>

	select.elem =
		element select { select.inner & select.attrs }	
	select.attrs =
		(	common.attrs
		&	common-form.attrs
		&	select.attrs.size?
		&	select.attrs.multiple?
		# FIXME onfocus, onblur, onchange
		)
		select.attrs.size =
			attribute size {
				common.data.integer.positive
			}
		select.attrs.multiple =
			attribute multiple {
				string "multiple"
			}
	select.inner =
		(	optgroup.elem*
		&	option.elem*
		)

	common.inner.struct-inline &= select.elem*
	common.inner.strict-inline &= select.elem*
	
## Shared Definitions for Complex Button
	
	button.attrs.value =
		attribute value {
			string
		}
	button.inner = 
		( common.inner.strict-bimorphic.static )
		#REVISIT expecting this to change into bimorphic.static
	
## Complex Submit Button: <button type='submit'>

	button.submit.elem =
		element button { button.inner & button.submit.attrs }	
	button.submit.attrs =
		(	common.attrs
		&	common-form.attrs
		&	common-form.attrs.accesskey?
		&	button.submit.attrs.type?
		&	button.attrs.value?
		)
		button.submit.attrs.type =
			attribute type {
				string "submit"
			}

	button.elem = button.submit.elem
	
## Complex Reset Button: <button type='reset'>

	button.reset.elem =
		element button { button.inner & button.reset.attrs }	
	button.reset.attrs =
		(	common.attrs
		&	common-form.attrs
		&	common-form.attrs.accesskey?
		&	button.reset.attrs.type
		&	button.attrs.value? #REVISIT I guess this still affects the DOM
		)
		button.reset.attrs.type =
			attribute type {
				string "reset"
			}

	button.elem |= button.reset.elem
	
## Complex Push Button: <button type='button'>

	button.button.elem =
		element button { button.inner & button.button.attrs }	
	button.button.attrs =
		(	common.attrs
		&	common-form.attrs
		&	common-form.attrs.accesskey?
		&	button.button.attrs.type
		&	button.attrs.value? #REVISIT I guess this still affects the DOM
		)
		button.button.attrs.type =
			attribute type {
				string "button"
			}

	button.elem |= button.button.elem

	common.inner.struct-inline &= button.elem*
	common.inner.strict-inline &= button.elem*

## Form: <form>

	form.elem =
		element form { form.inner & form.attrs }
	form.elem.static =
		element form { form.inner.static & form.attrs }
	form.attrs =
		(	common.attrs
		&	form.attrs.action? #REVISIT Should this be required anyway?
		&	form.attrs.method?
		&	form.attrs.enctype?
		&	common-form.attrs.name?
		)
		form.attrs.action =
			attribute action {
				common.data.uri
			}
		form.attrs.method =
			attribute method {
				form.attrs.method.data
			}
			form.attrs.method.data = 
				( string "get" | "post" )
		form.attrs.enctype =
			attribute enctype {
				form.attrs.enctype.data
			}
			form.attrs.enctype.data = 
				(	string "application/x-www-form-urlencoded" 
				|	string "multipart/form-data"
				)
		form.attrs.accept =
			attribute accept {
				form.data.mimetypelist #Using more precise WF2 data type
			}
		form.attrs.accept-charset =
			attribute accept-charset {
				form.data.charsetlist
			}	
	form.inner =
		( common.inner.block )
	form.inner.static =
		( common.inner.block.static )

	common.inner.block &= form.elem*
	common.inner.block.static &= form.elem.static*

## Fieldset Legend: <legend>

	legend.elem =
		element legend { legend.inner & legend.attrs }
	legend.elem.static =
		element legend { legend.inner.static & legend.attrs }
	legend.attrs =
		(	common.attrs
		&	common-form.attrs.accesskey? #REVISIT is this staying in HTML5?
		)	
	legend.inner =
		( common.inner.strict-inline ) #REVISIT making obvious guess
	legend.inner.static =
		( common.inner.strict-inline.static ) #REVISIT making obvious guess

## Fieldset: <fieldset>

	fieldset.elem =
		element fieldset { fieldset.inner & fieldset.attrs }
	fieldset.elem.static =
		element fieldset { fieldset.inner.static & fieldset.attrs }
	fieldset.attrs =
		(	common.attrs
		&	common-form.attrs.accesskey?
		)	
	fieldset.inner =
		(	legend.elem? #REVISIT should this be required?
		,	common.inner.strict-bimorphic
		) #REVISIT expecting this to change into bimorphic
	fieldset.inner.static =
		(	legend.elem? #REVISIT should this be required?
		,	common.inner.strict-bimorphic.static
		) #REVISIT expecting this to change into bimorphic

	#REVISIT is fieldset interactive?

	common.inner.block &= fieldset.elem*
	common.inner.block.static &= fieldset.elem.static*
